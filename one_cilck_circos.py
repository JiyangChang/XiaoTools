#!/usr/bin/env python3
"""
一键Circos

本脚本整合了从基因共线性分析到Circos图生成的全流程，主要功能包括：
1. 基因共线性分析（Diamond+MCScanX）
2. 重复序列密度计算
3. 核型文件生成
4. Circos配置文件生成
5. 可视化结果输出

使用示例：
    python circos_pipeline.py \\
        -g genome.fa \\
        -a genes.gff3 \\
        -p proteins.faa \\
        -n 5 \\
        -l ltr.gff3 \\
        --colors red blue green \\
        --gene_binsize 100000 \\
        --repeat_binsize 300000 \\
        -o output_dir

参数说明：
必要参数：
  -g, --genome        基因组FASTA文件
  -a, --gene_gff      基因注释GFF3文件
  -p, --prot          蛋白序列文件
  -n, --anchor_num    MCScanX锚定数
  -l, --ltr_gff       LTR注释GFF3文件

可选参数：
  --colors [COLOR...] 自定义染色体颜色列表（支持颜色名称或RGB值）
  --gene_binsize      基因窗口大小（默认：100000）
  --repeat_binsize    重复序列窗口大小（默认：300000）
  -c, --config        生成circos.conf所需要的配置文件，参考circos_config_template.yaml
  -o, --output_dir    输出目录（默认：当前目录）
"""

import os
import argparse
import subprocess
import logging
import pandas as pd
from jinja2 import Template
import yaml

# 配置日志格式
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# 常量定义
DEFAULT_COLORS = [
    "red", "blue", "green", "orange", "purple",
    "brown", "pink", "grey", "violet", "yellow"
]

# Circos模板（使用Jinja2语法）
CIRCOS_TEMPLATE = """# circos.conf
# Generated by Circos config generator

karyotype = {{ karyotype_file }}
chromosomes_units = {{ chromosomes_units }}

<ideogram>
<spacing>
default = 0.005r
</spacing>
radius           = 0.90r
thickness        = 30p
fill             = yes
stroke_color     = dgrey
stroke_thickness = 2p
show_label       = yes
label_font       = bold
label_radius     = 1r+75p
label_size       = 50
label_parallel   = yes
</ideogram>

<ticks>
radius           = 1r
color            = black
thickness        = 2p
multiplier       = 1e-6
format           = %d

<tick>
spacing        = 5u
size           = 10p
</tick>

<tick>
spacing        = 25u
size           = 15p
show_label     = yes
label_size     = 20p
label_offset   = 10p
format         = %d
</tick>
</ticks>

<plots>
{% for plot in plots %}
<plot>
type    = {{ plot.type | default("heatmap") }}
file    = {{ plot.file }}
r0      = {{ plot.r0 }}
r1      = {{ plot.r1 }}
color   = {{ plot.color }}
min     = {{ plot.min }}
max     = {{ plot.max }}
{# 以下处理不同类型专用参数 #}
{% if plot.type == "scatter" %}
glyph        = {{ plot.glyph | default("circle") }}
glyph_size   = {{ plot.glyph_size | default("8p") }}
{% elif plot.type == "histogram" %}
fill_color   = {{ plot.fill_color | default("lgrey") }}
{% endif %}
{% if plot.orientation %}orientation = {{ plot.orientation }}{% endif %}
</plot>
{% endfor %}
</plots>

<links>
<link>
file          = {{ links.file }}
radius        = {{ links.radius }}
bezier_radius = {{ links.bezier_radius }}
color         = {{ links.color }}
thickness     = {{ links.thickness }}

<rules>
<rule>
condition     = var(intrachr)
show          = no
</rule>
</rules>
</link>
</links>

<image>
<<include etc/image.conf>>
</image>

<<include etc/colors_fonts_patterns.conf>>
<<include etc/housekeeping.conf>>
"""

class CircosGenerator:
    def __init__(self, args):
        self.args = args
        self.output_dir = os.path.abspath(args.output_dir)
        self.colors = args.colors if args.colors else DEFAULT_COLORS
        self.validate_inputs()
        
        # 初始化环境
        # self.load_modules()
        os.makedirs(self.output_dir, exist_ok=True)
        logger.info(f"输出目录已创建：{self.output_dir}")

    def get_path(self, filename):
        """生成输出目录内的完整文件路径"""
        return os.path.join(self.output_dir, filename)

    def validate_inputs(self):
        """验证输入文件是否存在"""
        required = [self.args.genome, self.args.gene_gff, 
                   self.args.prot, self.args.ltr_gff, self.args.config]
        missing = [f for f in required if not os.path.exists(f)]
        if missing:
            raise FileNotFoundError(f"缺失必要文件：{', '.join(missing)}")
        logger.info("所有输入文件验证通过")

    def load_modules(self):
        """加载环境模块"""
        # [保留原有实现...]

    def run_command(self, cmd):
        """在输出目录中执行系统命令"""
        logger.info(f"执行命令：{cmd}")
        try:
            result = subprocess.run(
                cmd, 
                shell=True, 
                #cwd=self.output_dir,  # 关键修改：在输出目录执行命令
                check=True,
                capture_output=True,
                text=True
            )
            logger.debug(f"命令输出：{result.stdout}")
            return result.stdout
        except subprocess.CalledProcessError as e:
            logger.error(f"命令执行失败：{e.stderr}")
            raise RuntimeError(f"命令执行失败：{cmd}")

    def generate_links(self):
        """生成共线性链接文件"""
        logger.info("开始生成共线性链接...")
        
        # Diamond数据库路径保持在当前目录
        base_name = os.path.basename(self.args.prot).split('.')[0]
        db_path = self.get_path(base_name)
        
        # 修改所有输出文件路径
        cmds = [
            f"diamond makedb --in {self.args.prot} -d {db_path}",
            f"diamond blastp -d {db_path} -q {self.args.prot} -o {self.get_path('MCScan_in.blast')} --outfmt 6",
            f'''awk '$3~/mRNA/' {self.args.gene_gff} | awk -F ';' '{{print $1}}' | sed 's/ID=//g' | awk -F '\t' '{{print $1"\t"$9"\t"$4"\t"$5}}' > {self.get_path('MCScan_in.gff')}''',
            f"MCScanX {self.get_path('MCScan_in')} -b 1 -s {self.args.anchor_num}",
            f"grep -v '^#' {self.get_path('MCScan_in.collinearity')} | awk -F '\t' '{{print $2\"\t\"$3}}' > {self.get_path('collinearity.info')}"
        ]
        
        for cmd in cmds:
            self.run_command(cmd)
        
        # 处理共线性结果
        self.extract_collinearity_gff(
            self.get_path('collinearity.info'),
            self.get_path('MCScan_in.gff')
        )
        self.run_command(f"awk '{{print $1\"\t\"$3\"\t\"$4\"\t\"$5\"\t\"$7\"\t\"$8}}' {self.get_path('result.out')} > {self.get_path('links.tsv')}")

        logger.info("共线性链接生成完成")

    def extract_collinearity_gff(self, collinearity_file, gff_file):
        """提取共线性GFF信息"""
        output_file = self.get_path('result.out')
        logger.debug(f"处理共线性文件：{collinearity_file}")
        with open(collinearity_file) as f_in, open(output_file, "w") as f_out:
            for line in f_in:
                ids = line.strip().split("\t")
                with open(gff_file) as gff:
                    gff_content = gff.read().splitlines()
                    gff1 = next((l for l in gff_content if ids[0] in l), "")
                    gff2 = next((l for l in gff_content if ids[1] in l), "")
                f_out.write(f"{gff1}\t{gff2}\n")

    def generate_bed_files(self):
        """生成BED文件"""
        logger.info("开始生成BED文件...")
        cmds = [
            f"awk '$3 == \"gene\" {{print $1 \"\t\" $4 \"\t\" $5}}' {self.args.gene_gff} > {self.get_path('Gene.bed')}",
            f"grep 'Gypsy' {self.args.ltr_gff} | awk '$3 == \"Gypsy_LTR_retrotransposon\" {{print $1 \"\t\" $4 \"\t\" $5}}' > {self.get_path('Gypsy.bed')}",
            f"grep 'Copia' {self.args.ltr_gff} | awk '$3 == \"Copia_LTR_retrotransposon\" {{print $1 \"\t\" $4 \"\t\" $5}}' > {self.get_path('Copia.bed')}"
        ]
        for cmd in cmds:
            self.run_command(cmd)
        logger.info("BED文件生成完成")

    def generate_karyotype(self):
        """生成核型文件"""
        logger.info("开始生成核型文件...")
        self.run_command(f"samtools faidx {self.args.genome} -o {self.get_path('genome.fai')}")
        self.run_command(f"cut -f 1,2 {self.get_path('genome.fai')} | grep -i 'chr' | sort -k1,1n > {self.get_path('chrom.size')}")
        self.circos_karyotype_generator(
            self.get_path('chrom.size'),
            self.get_path('karyotype.txt')
        )
        logger.info("核型文件生成完成")

    def circos_karyotype_generator(self, input_file, output_file):
        """核型生成核心逻辑"""
        chromosomes = []
        with open(input_file) as f:
            for line in f:
                if line.strip() and not line.startswith("#"):
                    parts = line.strip().split()
                    if len(parts) >= 2:
                        chromosomes.append((parts[0], int(parts[1])))

        entries = []
        for i, (name, size) in enumerate(chromosomes):
            color = self.colors[i % len(self.colors)]
            entries.append(f"chr - {name} {name} 0 {size} {color}")

        with open(output_file, 'w') as f:
            f.write("\n".join(entries))
        logger.debug(f"生成染色体条目：{len(entries)}条")

    def generate_density_files(self):
        """生成密度文件"""
        logger.info("开始生成密度文件...")
        bins = {
            "gene.tsv": (self.args.gene_binsize, "Gene.bed"),
            "copia.tsv": (self.args.repeat_binsize, "Copia.bed"),
            "gypsy.tsv": (self.args.repeat_binsize, "Gypsy.bed")
        }
        for output, (window, bed) in bins.items():
            src = self.get_path(bed)
            dest = self.get_path(output)
            logger.debug(f"处理：{src} -> {dest}")
            self.count_features_in_windows(src, window, dest)
        logger.info("密度文件生成完成")

    def count_features_in_windows(self, bed_file, window_size, output_file):
        """窗口特征计数"""
        bed = pd.read_csv(bed_file, sep='\t', header=None, 
                         names=['chrom', 'start', 'end'])
        windows = []
        for chrom in bed['chrom'].unique():
            max_pos = bed[bed['chrom'] == chrom]['end'].max()
            for start in range(0, max_pos + window_size, window_size):
                windows.append((chrom, start, start + window_size))
        
        result = []
        for chrom, win_start, win_end in windows:
            count = len(bed[(bed['chrom'] == chrom) & 
                           (bed['start'] < win_end) & 
                           (bed['end'] > win_start)])
            result.append(f"{chrom}\t{win_start}\t{win_end}\t{count}")

        with open(output_file, 'w') as f:
            f.write("\n".join(result))
        logger.debug(f"已写入：{output_file} ({len(result)}条记录)")

    def generate_circos_config(self):
        """生成Circos配置"""
        logger.info("开始生成Circos配置文件...")
        
        # 读取模板并更新文件路径
        with open(self.args.config) as f:
            config = yaml.safe_load(f)
        
        # 更新所有文件路径为输出目录
        config['karyotype'] = self.get_path('karyotype.txt')
        for plot in config['plots']:
            plot['file'] = self.get_path(plot['file'])
        config['links']['file'] = self.get_path(config['links']['file'])
        
        # 生成配置文件
        output_conf = self.get_path('circos.conf')
        template = Template(CIRCOS_TEMPLATE)
        output = template.render(
            karyotype_file=config.get('karyotype', 'karyotype.txt'),
            chromosomes_units=config.get('chromosomes_units', 100000),
            plots=config['plots'],
            links=config['links']
        )
        with open(output_conf, 'w') as f:
            f.write(output)
        logger.info(f"Circos配置文件已生成：{output_conf}")

    def run(self):
        """主流程控制器"""
        try:
            logger.info("="*50)
            logger.info("Circos流程启动")
            self.generate_links()
            self.generate_bed_files()
            self.generate_karyotype()
            self.generate_density_files()
            self.generate_circos_config()
            self.run_command(f"circos -conf {self.get_path('circos.conf')} --outputdir {self.output_dir}")
            logger.info("="*50)
            logger.info(f"流程成功完成，结果保存在：{self.output_dir}")
        except Exception as e:
            logger.error(f"流程执行失败：{str(e)}")
            raise

if __name__ == "__main__":
    # 使用文档字符串作为帮助描述
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # 必要参数
    parser.add_argument('-g', '--genome', required=True, help='基因组FASTA文件')
    parser.add_argument('-a', '--gene_gff', required=True, help='基因注释GFF3文件')
    parser.add_argument('-p', '--prot', required=True, help='蛋白序列文件')
    parser.add_argument('-n', '--anchor_num', type=int, required=True, help='MCScanX锚定数')
    parser.add_argument('-l', '--ltr_gff', required=True, help='LTR注释GFF3文件')
    parser.add_argument('-c', '--config', required=True, default='circos_config_template.yaml', help='Circos模板文件')

    # 可选参数
    parser.add_argument('--colors', nargs='+', help='自定义染色体颜色列表')
    parser.add_argument('--gene_binsize', type=int, default=100000, help='基因窗口大小')
    parser.add_argument('--repeat_binsize', type=int, default=300000, help='重复序列窗口大小')
    parser.add_argument('-o', '--output_dir', default='./', help='输出目录')
    
    args = parser.parse_args()
    
    try:
        generator = CircosGenerator(args)
        generator.run()
    except Exception as e:
        logger.error(f"致命错误：{str(e)}")
        exit(1)